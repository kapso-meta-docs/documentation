---
title: "Subagent Node"
description: "Combines multiple tool types into a single powerful node"
icon: "robot"
---

The Subagent Node combines multiple tool types (Webhooks, Knowledge Bases, WhatsApp Templates) into a single powerful node that can dynamically decide when to use each tool.

<div style={{position: "relative", paddingBottom: "56.25%", height: 0, overflow: "hidden", width: "100%"}}>
  <iframe
    style={{position: "absolute", top: 0, left: 0, width: "100%", height: "100%"}}
    src="https://www.tella.tv/video/cmakef2jv002h0bl26qg80vhe/embed?b=0&title=0&a=1&loop=0&t=0&muted=0&wt=0"
    allowFullScreen
    allowTransparency
  ></iframe>
</div>

### Purpose & Functionality

The Subagent Node extends beyond basic conversation by enabling access to various tools within a single node. It combines:

- **Webhooks**: Make API calls to external services
- **Knowledge Bases**: Access specific information sources
- **WhatsApp Templates**: Send structured messages

The subagent autonomously determines when to use each tool based on conversation context, allowing for more flexible and dynamic interactions.

### Use Cases

- Complex customer support flows
- Information gathering and processing
- Dynamic data retrieval and sending
- Multi-step processes with variable paths
- Multi-agent architectures (see below)

### Configuration

- **Name:** A descriptive name for the node
- **Prompt:** Instructions for the agent's behavior and goals
- **Global Node:** Option to make this node accessible from anywhere in the graph

#### Webhook Configuration

Each webhook within a subagent can be configured with:

- **Name:** A descriptive name for the webhook (required)
- **Description:** Brief explanation of the webhook's purpose
- **URL:** The endpoint to call (required). Supports variable interpolation using `#{variable}` syntax.
- **HTTP Method:** GET, POST, PUT, PATCH, DELETE (required)
- **Headers:** JSON object of request headers (defaults to `{}`). Supports variable interpolation using `#{variable}` syntax.
- **Body Schema:** JSON Schema defining the structure and validation rules for the request body. This is the preferred way to define request bodies.
- **Body:** JSON object of request data (defaults to `{}`). **Note: This field is being deprecated in favor of Body Schema.**
- **JMESPath Query:** (Optional) Query to transform and filter the webhook response before passing it to the agent.
- **Mock Response Enabled:** Toggle to use the mock response instead of making a real HTTP request
- **Mock Response:** JSON object to return when mock response is enabled

### Variable Interpolation

The `#{variable}` syntax can be used to insert dynamic values into:

- **URLs:** `https://api.example.com/customers/#{customer_id}`
- **Headers:** `"Authorization": "Bearer #{access_token}"`
- **Request Bodies:** Values will be substituted in the bodies generated from the body schema

Variables can come from conversation context, previous node outputs, or graph-level variables.

### Body Schema

The **Body Schema** defines the structure of webhook requests using JSON Schema format and is now the preferred way to define request bodies. It supports:

- Different data types (string, number, boolean, array, object)
- Required fields
- Property descriptions
- Nested objects and arrays
- Enum values for string fields

```json
{
  "type": "object",
  "properties": {
    "customer_id": {
      "type": "string",
      "description": "Unique identifier for the customer"
    },
    "preferences": {
      "type": "object",
      "properties": {
        "notifications": {
          "type": "boolean",
          "description": "Whether to send notifications"
        },
        "categories": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Product categories of interest"
        }
      }
    }
  },
  "required": ["customer_id"]
}
```

### Multi-Agent Architectures

The Subagent Node supports various multi-agent system designs as described in [Anthropic's guide on effective agents](https://www.anthropic.com/engineering/building-effective-agents):

- **Orchestrator-Worker**: A primary agent delegates tasks to specialized worker agents
- **Evaluator-Optimizer**: One agent generates responses while another evaluates and provides feedback
- More [Anthropic's guide](https://www.anthropic.com/engineering/building-effective-agents).

### Examples

**Example 1: Customer Support Subagent**

Available tools:
- **Webhooks**: order-status, initiate-return, check-inventory
- **Knowledge Bases**: product-catalog, return-policy
- **WhatsApp Templates**: return-instructions, order-confirmation

```
You are a customer support agent for an e-commerce store.
Use the product knowledge base to answer questions about items.
When customers want to check order status, use the order-status webhook.
If a customer wants to initiate a return, send them the appropriate WhatsApp template with instructions.
Determine which tool is most appropriate based on the customer's needs.
```

**Example 2: Appointment Scheduling Subagent with Variable Interpolation**

Available tools:
- **Webhooks**: 
  - available-slots (URL: `https://api.clinic.com/slots?date=#{date}&doctor=#{doctor_id}`)
  - book-appointment 
  - cancel-appointment
- **Knowledge Bases**: provider-info, clinic-locations, insurance-coverage
- **WhatsApp Templates**: appointment-confirmation, reminder, reschedule-options

```
You help patients schedule medical appointments.
Check the available-slots webhook to find open appointment times, using the date and doctor ID from the conversation.
Use the provider-info knowledge base to answer questions about doctors.
Send appointment confirmation using the appointment-confirmation WhatsApp template when scheduling is complete.
```

### Best Practices

- Give each webhook a clear, descriptive name to help the agent choose the right tool
- Provide detailed descriptions for webhooks to help the agent understand when to use them
- Use variables (`#{variable}`) in URLs and headers for dynamic values
- Define comprehensive body schemas instead of using the deprecated body field
- Use mock responses during development and testing
- In the prompt, clearly instruct the agent about when to use each webhook versus other tools

## Related Nodes

<CardGroup cols={3}>
  <Card title="Default Node" icon="message" href="./default-node">
    Basic conversation and reasoning node
  </Card>
  <Card title="Webhook Node" icon="webhook" href="./webhook-node">
    Dedicated node for API requests
  </Card>
  <Card title="Knowledge Base Node" icon="database" href="./knowledge-base-node">
    Access specific knowledge sources
  </Card>
</CardGroup>
